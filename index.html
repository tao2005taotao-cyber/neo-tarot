
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>NEO TAROT</title>
    <style>
        /* =========================================
           å…¨å±€æ ·å¼ (Global Styles)
           ========================================= */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            /* ğŸ”´ Core Mod: Force disable scrolling and use fixed positioning */
            /* ğŸ”´ æ ¸å¿ƒä¿®æ”¹ï¼šå¼ºåˆ¶ç¦æ­¢æ»šåŠ¨ï¼Œä¸”å›ºå®šå®šä½ */
            overflow: hidden;
            position: fixed;
            background-color: #000;
            font-family: 'Times New Roman', 'Songti SC', 'SimSun', serif;
            -webkit-tap-highlight-color: transparent;
            /* Prevent iOS rubber-band scrolling / é˜²æ­¢ iOS æ©¡çš®ç­‹å›å¼¹æ•ˆæœ */
            overscroll-behavior: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Default cursor is pointer / é»˜è®¤é¼ æ ‡æ˜¯æŒ‡é’ˆ */
        body {
            cursor: default;
        }

        /* When hovering over the axis area (Controlled by JS) */
        /* å½“é¼ æ ‡æ‚¬åœåœ¨ä¸­è½´åŒºåŸŸæ—¶ (JSæ§åˆ¶ç±»å) */
        body.can-grab {
            cursor: grab;
        }

        body.is-grabbing {
            cursor: grabbing;
        }

        /* =========================================
           åˆå§‹ç•Œé¢ (Start Screen)
           ========================================= */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.95) 90%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1.5s cubic-bezier(0.25, 1, 0.5, 1);
            color: #d4af37;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Title Animation & Styles / æ ‡é¢˜åŠ¨ç”»ä¸æ ·å¼ */
        .title-group {
            text-align: center;
            margin-bottom: 5vh;
            position: relative;
            animation: floatTitle 6s ease-in-out infinite;
        }

        h1 {
            font-size: 72px;
            margin: 0;
            letter-spacing: 20px;
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #996515 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
            position: relative;
        }

        h2 {
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 8px;
            color: #a0a0a0;
            margin-top: 15px;
            text-transform: uppercase;
            opacity: 0.8;
            border-top: 1px solid rgba(212, 175, 55, 0.3);
            display: inline-block;
            padding-top: 15px;
            width: 120%;
            margin-left: -10%;
        }

        .exclusive-text {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 4px;
            color: #d4af37;
            margin-top: 10px;
            text-transform: uppercase;
            opacity: 0.9;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            animation: floatTitle 4s ease-in-out infinite;
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Options Grid / é€‰é¡¹æŒ‰é’®ç½‘æ ¼ */
        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 60px;
            margin-bottom: 5vh;
            text-align: center;
            opacity: 0;
            animation: fadeUp 1s ease-out 0.5s forwards;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .option-label {
            font-size: 11px;
            letter-spacing: 3px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
            font-weight: 600;
        }

        /* Capsule Button Styles / èƒ¶å›ŠæŒ‰é’®æ ·å¼ */
        .choice-btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(212, 175, 55, 0.3);
            color: #888;
            padding: 12px 0;
            width: 160px;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            border-radius: 50px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(2px);
        }

        .choice-btn.active {
            border-color: #d4af37;
            color: #fff;
            background: rgba(212, 175, 55, 0.15);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.15);
        }

        .choice-btn:hover {
            border-color: #fff;
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        /* Enter Button Effects / è¿›å…¥æŒ‰é’®ç‰¹æ•ˆ */
        #enter-btn {
            background: transparent;
            color: #d4af37;
            border: 1px solid #d4af37;
            padding: 18px 80px;
            font-size: 16px;
            letter-spacing: 8px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
            border-radius: 50px;
            transition: all 0.5s;
            position: relative;
            overflow: hidden;
            opacity: 0;
            animation: fadeUp 1s ease-out 0.8s forwards;
        }

        #enter-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.2), transparent);
            transition: 0.5s;
        }

        #enter-btn:hover::before {
            left: 100%;
            transition: 0.7s;
        }

        #enter-btn:hover {
            background: #d4af37;
            color: #000;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.4);
            transform: scale(1.05);
            letter-spacing: 10px;
        }

        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Mystical Sparkles / ç¥ç§˜å­¦é—ªå…‰ç²’å­ */
        .sparkle {
            position: absolute;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            box-shadow: 0 0 10px #d4af37, 0 0 20px #d4af37;
            animation: sparkleFloat linear forwards;
        }

        @keyframes sparkleFloat {
            0% { opacity: 0; transform: translateY(0) scale(0); }
            50% { opacity: 1; transform: translateY(-50px) scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(0); }
        }

        /* =========================================
           è¾“å…¥ç•Œé¢ç¾åŒ– (è¦†ç›–æ—§æ ·å¼)
           Input Screen Styling
           ========================================= */
        #input-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 90;
            /* Semi-transparent background to show 3D stars / èƒŒæ™¯ä¿æŒåŠé€æ˜ï¼Œè®©èƒŒåçš„ 3D æ˜Ÿç©ºé€å‡ºæ¥ */
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 1.0s;
            backdrop-filter: blur(0px);
        }

        /* Frosted Glass Card / ç£¨ç ‚ç»ç’ƒå¡ç‰‡ */
        .input-card {
            width: 90%;
            max-width: 400px;
            padding: 40px 30px;
            background: rgba(10, 10, 10, 0.6); /* Dark semi-transparent / æ·±è‰²åŠé€æ˜åº• */
            border: 1px solid rgba(212, 175, 55, 0.2); /* Faint gold border / ææ·¡çš„é‡‘è¾¹ */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            /* Key frosted effect / ç£¨ç ‚æ•ˆæœå…³é”® */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transform: translateY(0);
            transition: transform 0.3s;
        }

        /* Top Decoration / é¡¶éƒ¨è£…é¥°æ˜Ÿå· */
        .input-decoration {
            color: #d4af37;
            font-size: 20px;
            margin-bottom: 15px;
            opacity: 0.8;
            animation: pulse 2s infinite;
        }

        /* Title Style / æ ‡é¢˜æ ·å¼ */
        #input-prompt {
            font-family: 'Times New Roman', serif;
            color: #fff;
            font-size: 16px;
            letter-spacing: 6px;
            font-weight: 400;
            margin: 0 0 30px 0;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        /* Input Field - Minimalist Line / è¾“å…¥æ¡†æ ·å¼ - æç®€çº¿æ¡é£ */
        #user-question {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(212, 175, 55, 0.3); /* Bottom line only / åªæœ‰åº•è¾¹çº¿ */
            color: #d4af37;
            font-family: 'Times New Roman', serif;
            font-size: 20px;
            text-align: center;
            padding: 10px 0;
            margin-bottom: 40px;
            outline: none;
            resize: none;
            border-radius: 0;
            transition: border-color 0.3s;
        }

        #user-question:focus {
            border-bottom-color: #d4af37;
        }

        #user-question::placeholder {
            color: rgba(255, 255, 255, 0.2);
            font-size: 14px;
            letter-spacing: 2px;
            font-style: italic;
        }

        /* Button Style / æŒ‰é’®æ ·å¼ */
        #confirm-question-btn {
            background: transparent;
            color: #d4af37;
            border: 1px solid rgba(212, 175, 55, 0.4);
            padding: 12px 50px;
            font-size: 12px;
            letter-spacing: 4px;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }

        #confirm-question-btn:hover {
            background: rgba(212, 175, 55, 0.1);
            border-color: #d4af37;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            transform: scale(1.05);
        }

        /* Mobile Adaptation / ç§»åŠ¨ç«¯ç‰¹æ®Šé€‚é… */
        @media (max-width: 768px) {
            .input-card {
                padding: 30px 20px;
                width: 85%;
                margin-top: -10%; /* Lift slightly for keyboard / ç¨å¾®å¾€ä¸Šæä¸€ç‚¹ï¼Œé¿å¼€æ‰‹æœºé”®ç›˜ */
            }
            #input-prompt {
                font-size: 14px;
                letter-spacing: 4px;
            }
            #user-question {
                font-size: 18px;
                margin-bottom: 30px;
            }
        }

        /* =========================================
           æ¸¸æˆå†… UI å±‚ (Game UI Layer)
           ========================================= */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            color: #d4af37;
            opacity: 0;
            transition: opacity 1.5s;
        }

        /* --- New: Axis Markers / æ–°å¢ï¼šä¸­è½´æŒ‡é’ˆ --- */
        #axis-markers {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px; /* Very thin axis container / æç»†çš„ä¸­è½´çº¿å®¹å™¨ */
            height: 100%;
            /* âš ï¸ Core Z-index control: Acts like background / æ ¸å¿ƒå±‚çº§æ§åˆ¶ï¼šè¡¨ç°å¾—åƒæ˜¯åœ¨â€œèƒŒæ™¯â€é‡Œ */
            z-index: 5;
            pointer-events: none;
            opacity: 0.4;
        }

        /* Top Pointer / ä¸ŠæŒ‡é’ˆ */
        #axis-markers::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            height: 30px;
            background: linear-gradient(to bottom, transparent, #ccd437);
        }

        /* Top Pointer Decoration (12 o'clock feel) / ä¸ŠæŒ‡é’ˆçš„è£…é¥°ç‚¹ (12ç‚¹é’Ÿåˆ»åº¦æ„Ÿ) */
        #axis-markers::after {
            content: '';
            position: absolute;
            top: calc(20% + 35px);
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 4px;
            height: 4px;
            border: 1px solid #ccd437;
            background: transparent;
            opacity: 0.6;
        }

        /* Bottom Pointer / ä¸‹æŒ‡é’ˆ */
        .bottom-marker {
            position: absolute;
            bottom: 12%;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            height: 100%;
        }

        .bottom-marker::before {
            content: '';
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            height: 30px;
            background: linear-gradient(to top, transparent, #ccd437);
        }

        .bottom-marker::after {
            content: '';
            position: absolute;
            bottom: calc(20% + 35px);
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 4px;
            height: 4px;
            border: 1px solid #ccd437;
            background: transparent;
            opacity: 0.6;
        }

        /* History Bar / å†å²è®°å½•æ  */
        #history-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: row;
            gap: 15px;
            pointer-events: auto;
            z-index: 30;
            height: 100px;
            align-items: flex-start;
            transition: opacity 1s ease;
        }

        .history-slot {
            width: 50px;
            height: 85px;
            background: #fff;
            border: 2px solid #d4af37;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8);
            flex-shrink: 0;
            position: relative;
            animation: slotEnter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        @keyframes slotEnter {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .history-slot img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .history-info {
            position: relative;
            z-index: 2;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            text-align: center;
            padding: 2px 0;
            border-top: 1px solid #d4af37;
        }

        .history-name {
            font-size: 8px;
            color: #d4af37;
            font-weight: 700;
            white-space: nowrap;
            transform: scale(0.9);
        }

        .history-rev {
            font-size: 7px;
            color: #ff3333;
            display: none;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            width: 100%;
        }

        .is-reversed img {
            transform: rotate(180deg);
        }

        .is-reversed .history-rev {
            display: block;
        }

        /* Bottom HUD / åº•éƒ¨ HUD */
        #hud-center {
            position: absolute;
            bottom: 8%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #d4af37;
            pointer-events: none;
            width: 100%;
            background: transparent;
            border-radius: 0;
        }

        #hud-center:active {
            transform: none;
            background: transparent;
        }

        #gesture-icon {
            font-size: 32px;
            display: block;
            margin-bottom: 10px;
            opacity: 0.9;
            text-shadow: 0 0 15px #d4af37;
        }

        #status-text {
            font-size: 11px;
            letter-spacing: 4px;
            text-transform: uppercase;
            font-weight: 600;
            opacity: 0.8;
        }

        /* Final Text Container / æœ€ç»ˆç»“æœæ–‡å­—å®¹å™¨ */
        #final-text-container {
            position: absolute;
            top: 65%;
            left: 0;
            width: 100%;
            text-align: center;
            opacity: 0;
            transition: opacity 2s;
            pointer-events: none;
            display: flex;
            justify-content: center;
            gap: 120px;
            flex-wrap: wrap;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .final-card-label {
            display: flex;
            flex-direction: column;
            width: 220px;
            color: #fff;
            text-shadow: 0 0 10px #d4af37;
            text-align: center;
            animation: textFloat 3s ease-in-out infinite alternate;
            margin-bottom: 20px;
        }

        @keyframes textFloat {
            from { transform: translateY(0); }
            to { transform: translateY(-5px); }
        }

        .final-name {
            font-size: 15px;
            font-weight: bold;
            color: #d4af37;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(212, 175, 55, 0.3);
            padding-bottom: 5px;
        }

        .final-meaning {
            font-size: 11px;
            color: #ccc;
            font-style: italic;
            line-height: 1.5;
            opacity: 0.8;
        }

        /* Restart UI (Includes View Guide) / é‡å¯æŒ‰é’®åŒºåŸŸ (åŒ…å«æŸ¥çœ‹æŒ‡å¼•) */
        #end-ui {
            position: absolute;
            bottom: 12%;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s;
            z-index: 50;
            gap: 20px;
        }

        #restart-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #d4af37;
            color: #d4af37;
            padding: 12px 50px;
            font-size: 13px;
            letter-spacing: 4px;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            transition: 0.4s;
            backdrop-filter: blur(5px);
        }

        #restart-btn:hover {
            background: #d4af37;
            color: #000;
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.6);
        }

        /* New: View Guide Button / æ–°å¢ï¼šæŸ¥çœ‹æŒ‡å¼•æŒ‰é’® */
        #view-reading-btn {
            background: #d4af37;
            color: #000;
            border: 1px solid #d4af37;
            padding: 15px 60px;
            font-size: 14px;
            letter-spacing: 4px;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: 0.4s;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
        }

        #view-reading-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.8);
        }

        /* New: Oracle Overlay Container / æ–°å¢ï¼šè§£è¯´æ–‡å­—å…¨å±å®¹å™¨ */
        #oracle-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 700px;
            text-align: center;
            color: #fff;
            font-size: 18px;
            line-height: 2.0;
            font-family: 'Noto Serif SC', serif;
            text-shadow: 0 0 10px #d4af37;
            z-index: 60;
            pointer-events: none;
            opacity: 1;
        }

        /* Loading Pulse Animation / Loading å‘¼å¸ç¯åŠ¨ç”» */
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }

        /* --- Credits / åˆ¶ä½œäººå‘˜ä¿¡æ¯ --- */
        #credits {
            position: absolute;
            bottom: 20px;
            right: 25px;
            text-align: right;
            color: #a0a0a0;
            font-size: 10px;
            line-height: 1.6;
            opacity: 0;
            transition: opacity 1.5s;
            pointer-events: none;
            z-index: 50;
            font-family: 'Noto Serif SC', serif;
            letter-spacing: 1px;
        }

        #video-feed {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 100px;
            opacity: 0;
            transform: scaleX(-1);
            pointer-events: none;
            border: 1px solid #d4af37;
            transition: opacity 0.5s;
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d4af37;
            letter-spacing: 6px;
            font-size: 12px;
            font-weight: bold;
            z-index: 200;
        }

        /* =========================================
           Music Control Styles / éŸ³ä¹å¼€å…³æ ·å¼
           ========================================= */
        #music-control {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            border: 1px solid #d4af37;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 200;
            background: rgba(0, 0, 0, 0.6);
            transition: all 0.3s;
            opacity: 0.7;
        }

        #music-control:hover {
            opacity: 1;
            box-shadow: 0 0 10px #d4af37;
            transform: scale(1.1);
        }

        .music-icon {
            font-size: 20px;
            user-select: none;
            animation: rotateMusic 4s linear infinite;
        }

        /* Slash line when muted / å…³é—­çŠ¶æ€ä¸‹çš„æ–œæ  */
        .music-line {
            position: absolute;
            width: 80%;
            height: 2px;
            background: #ff3333;
            transform: rotate(45deg) scale(0);
            transition: transform 0.3s;
        }

        #music-control.muted .music-icon {
            animation-play-state: paused;
            opacity: 0.5;
        }

        #music-control.muted .music-line {
            transform: rotate(45deg) scale(1);
        }

        @keyframes rotateMusic {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* =========================================
           Mobile Adaptation (Responsive Styles)
           ç§»åŠ¨ç«¯é€‚é…
           ========================================= */
        @media (max-width: 768px) {
            h1 { font-size: 42px; letter-spacing: 8px; }
            h2 { font-size: 10px; letter-spacing: 4px; }
            .exclusive-text { font-size: 12px; letter-spacing: 3px; }
            .options-grid { grid-template-columns: 1fr; gap: 30px; margin-bottom: 30px; }
            .choice-btn { padding: 10px 0; width: 200px; }
            #enter-btn { padding: 15px 60px; font-size: 14px; }
            #axis-markers::before { top: 15%; }
            #axis-markers::after { top: calc(15% + 35px); }
            .bottom-marker { bottom: 20%; }

            /* Mobile History Bar: Centered at Top / ç§»åŠ¨ç«¯å†å²è®°å½•ç½®é¡¶å±…ä¸­ */
            #history-container {
                top: 10px;
                right: 50%;
                transform: translateX(50%);
                height: 70px;
                gap: 10px;
            }
            .history-slot { width: 40px; height: 65px; }
            .history-name { font-size: 6px; }

            /* HUD Adjustments / HUD è°ƒæ•´ */
            #hud-center { bottom: 15%; }
            #status-text { font-size: 10px; letter-spacing: 2px; }

            /* Shrink Credits / åˆ¶ä½œäººå‘˜ä¿¡æ¯ç¼©å° */
            #credits { text-align: center; right: 0; width: 100%; bottom: 10px; font-size: 8px; }

            /* Final Result Text Adjustments / æœ€ç»ˆç»“æœæ–‡å­—è°ƒæ•´ */
            #final-text-container {
                top: 47%;
                flex-direction: column;
                align-items: center;
                max-height: 40vh;
                overflow-y: auto;
                gap: 10px;
            }
            .final-card-label { width: 100%; max-width: 300px; }

            /* Oracle Text Smaller on Mobile / è§£è¯´æ–‡å­—åœ¨æ‰‹æœºä¸Šå°ä¸€ç‚¹ */
            #oracle-overlay { font-size: 14px; width: 90%; }
        }
    </style>

    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div id="loader"></div>

    <audio id="bgm-intro" loop preload="auto">
        <source src="./audio/bgm1.mp3" type="audio/mpeg">
    </audio>

    <audio id="bgm-final" loop preload="auto">
        <source src="./audio/bgm2.mp3" type="audio/mpeg">
    </audio>

    <div id="music-control" onclick="toggleMusic()">
        <div class="music-icon">ğŸµ</div>
        <div class="music-line"></div>
    </div>

    <div id="start-screen">
        <div class="title-group">
            <h1>NEO TAROT</h1>
            <h2 id="subtitle">THE CYBER ARCANUM</h2>
            <h3 class="exclusive-text">ææ™“èŒå’Œé’®æ€¡ç„¶ä¸“å±</h3>
        </div>

        <div class="options-grid">
            <div class="option-group">
                <div class="option-label" id="lbl-language">Language / è¯­è¨€</div>
                <button class="choice-btn active" onclick="setLang('en')" id="btn-en">English</button>
                <button class="choice-btn" onclick="setLang('zh')" id="btn-zh">ä¸­æ–‡</button>
            </div>
            <div class="option-group">
                <div class="option-label" id="lbl-input">Input / æ“æ§</div>
                <button class="choice-btn active" onclick="setInput('hand')" id="btn-hand">Hand Gesture âœ‹</button>
                <button class="choice-btn" onclick="setInput('mouse')" id="btn-mouse">Mouse / Touch ğŸ–±ï¸</button>
            </div>
        </div>

        <button id="enter-btn" onclick="enterExperience()">ENTER</button>
    </div>

    <div id="input-screen" style="display: none;">
        <div class="input-card">
            <div class="input-decoration">âœ¦</div>
            <h2 id="input-prompt">CONSULT THE VOID</h2>
            <div class="input-line"></div>
            <textarea id="user-question" rows="1" maxlength="50"></textarea>
            <button id="confirm-question-btn" onclick="submitQuestion()">INITIATE</button>
        </div>
    </div>

    <div id="ui-layer">
        <div id="axis-markers">
            <div class="bottom-marker"></div>
        </div>
        <div id="debug-axis-info"></div>

        <div id="history-container"></div>
        <div id="final-text-container"></div>
        <div id="oracle-overlay"></div>

        <div id="end-ui">
            <button id="view-reading-btn" onclick="enterStarryVoid()">REVEAL DESTINY</button>
            <button id="restart-btn" onclick="location.reload()" style="display:none">RESTART RITUAL</button>
        </div>

        <div id="credits">
            By: Jerry Hu & Gemini<br>huqiuzhi10@gmail.com
        </div>

        <div id="hud-center">
            <span id="gesture-icon">âœ‹</span>
            <div id="status-text">Wave to Turn Â· Pinch to Select</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // Mobile Viewport Correction / ç§»åŠ¨ç«¯è§†å£ä¿®æ­£
    // ==========================================

    // 1. Force scroll to top on refresh and disable browser's default "scroll restoration"
    // 1. åˆ·æ–°æ—¶å¼ºåˆ¶å›åˆ°é¡¶éƒ¨ï¼Œå¹¶ç¦ç”¨æµè§ˆå™¨é»˜è®¤çš„â€œè®°ä½æ»šåŠ¨ä½ç½®â€
    if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }
    window.scrollTo(0, 0);

    // 2. Listen for input blur to close keyboard
    // 2. ç›‘å¬è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹ (é”®ç›˜æ”¶èµ·)
    // Wait for DOM content to load / ç­‰ DOM åŠ è½½å®Œå†ç»‘å®š
    window.addEventListener('DOMContentLoaded', () => {
        const inputArea = document.getElementById('user-question');
        if (inputArea) {
            inputArea.addEventListener('blur', () => {
                // Delay slightly to wait for keyboard animation, then force scroll to top
                // å»¶æ—¶ä¸€ç‚¹ç‚¹ï¼Œç­‰é”®ç›˜åŠ¨ç”»æ”¶å®Œï¼Œå¼ºåˆ¶æ»šå›é¡¶éƒ¨
                setTimeout(() => {
                    window.scrollTo(0, 0);
                    document.body.scrollTop = 0;
                }, 100);
            });
        }
    });

    // ==========================================
    // API Configuration / API é…ç½®åŒºåŸŸ
    // ==========================================
    // ğŸ”´ Please enter your Volcano AI Gateway API Key here / è¯·åœ¨è¿™é‡Œå¡«å…¥ä½ çš„ç«å±±æ–¹èˆŸAIç½‘å…³ API Key
    const API_KEY = "sk-dd569690bfd1442f8f1bffb434b1e252yigzqx6l503qljoe";

    // Volcano AI Gateway API Endpoint / ç«å±±æ–¹èˆŸAIç½‘å…³æ¥å£åœ°å€
    const API_ENDPOINT = "https://ai-gateway.vei.volces.com/v1/chat/completions";

    // Volcano AI Gateway Model Name / ç«å±±æ–¹èˆŸAIç½‘å…³æ¨¡å‹åç§°
    const API_MODEL = "doubao-seed-1.6";

    // ğŸ”µ Proxy Toggle: Only active during final API call / ä»£ç†å¼€å…³ï¼šåªåœ¨æœ€åè°ƒç”¨ API æ—¶ç”Ÿæ•ˆ
    const USE_PROXY_FOR_API = true; // æ”¹ä¸º falseï¼Œå°è¯•åœ¨å›½å†…ç½‘ç»œç¯å¢ƒä¸‹ç›´è¿ç«å±±å¼•æ“

    // Proxy Service URL (Used only for API call) / ä»£ç†æœåŠ¡åœ°å€ (ä»…åœ¨ API è°ƒç”¨ç¬é—´ä½¿ç”¨)
    const PROXY_BASE_URL = "https://corsproxy.io/?";

    // Debug Mode / è°ƒè¯•å¼€å…³
    const DEBUG_MODE = true;
    // ==============================================


    // Detect if mobile device / æ£€æµ‹æ˜¯å¦ç§»åŠ¨è®¾å¤‡
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // 1. Sparkle Effect Logic / é—ªå…‰ç‰¹æ•ˆé€»è¾‘
    function createSparkles() {
        const screen = document.getElementById('start-screen');
        if (screen.style.display === 'none') return;

        const sparkle = document.createElement('div');
        sparkle.className = 'sparkle';

        // Random Position / éšæœºä½ç½®
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        sparkle.style.left = x + '%';
        sparkle.style.top = y + '%';

        // Random Size and Duration / éšæœºå¤§å°å’ŒæŒç»­æ—¶é—´
        const size = Math.random() * 3 + 1;
        sparkle.style.width = size + 'px';
        sparkle.style.height = size + 'px';
        sparkle.style.animationDuration = (Math.random() * 2 + 2) + 's';

        screen.appendChild(sparkle);

        // Remove after animation / åŠ¨ç”»ç»“æŸåç§»é™¤virtul
        setTimeout(() => { sparkle.remove(); }, 4000);
    }
    setInterval(createSparkles, 200);


    /**
     * DATA & CONFIG
     */
    const TEXTS = {
        en: {
            subtitle: "THE CYBER ARCANUM",
            lblLang: "Language",
            lblInput: "Input Method",
            enter: "ENTER VOID",
            statusWave: "Wave to Turn Â· Pinch Center Card Â· Clench to Reveal",
            statusMouse: "Move to Turn Â· Hold to Grab Â· Long Press to Reveal",
            statusTouch: "Swipe to Turn Â· Pull Down to Grab / Reveal",
            statusFist: "FIST TO REVEAL",
            statusSpace: "SPACE / HOLD TO REVEAL",
            statusReveal: "OBSERVING FATE...",
            statusDone: "RITUAL COMPLETE",
            rev: "Reversed",
            restart: "RESTART RITUAL",
            btnHand: "Hand Gesture âœ‹",
            btnMouse: isMobile ? "Touch Control ğŸ‘†" : "Mouse Control ğŸ–±ï¸",
            inputPrompt: "What do you seek?",
            inputPlaceholder: "Enter your query...",
            btnBegin: "SEEK ANSWER"
        },
        zh: {
            subtitle: "è™šæ‹Ÿå¡”ç½—ä»ªå¼",
            lblLang: "è¯­è¨€è®¾ç½®",
            lblInput: "æ“æ§æ–¹å¼",
            enter: "è¿›å…¥è™šç©º",
            statusWave: "æŒ¥æ‰‹è½¬åŠ¨ç‰Œé˜µ Â· æåˆæ‰‹æŒ‡é€‰ä¸­ Â· æ¡æ‹³æ­ç¤º",
            statusMouse: "ç§»åŠ¨é¼ æ ‡è½¬åŠ¨ Â· æŒ‰ä½å·¦é”®æŠ“å– Â· é•¿æŒ‰æ­ç¤º",
            statusTouch: "å·¦å³æ»‘åŠ¨è½¬åŠ¨ Â· ä¸‹æ‹‰æŠ“å–/æ­ç¤º",
            statusFist: "æ¡æ‹³æ­ç¤ºå‘½è¿",
            statusSpace: "æŒ‰ç©ºæ ¼ / é•¿æŒ‰æ­ç¤º",
            statusReveal: "æ­£åœ¨è§‚æµ‹å‘½è¿...",
            statusDone: "ä»ªå¼å®Œæˆ",
            rev: "é€†ä½",
            restart: "é‡æ–°å¼€å§‹ä»ªå¼",
            btnHand: "æ‰‹åŠ¿æ§åˆ¶ âœ‹",
            btnMouse: isMobile ? "è§¦å±æ§åˆ¶ ğŸ‘†" : "é¼ æ ‡æ§åˆ¶ ğŸ–±ï¸",
            inputPrompt: "å¿ƒä¸­æ‰€é—®",
            inputPlaceholder: "åœ¨æ­¤è¾“å…¥...",
            btnBegin: "å¼€å§‹æ¢å¯»"
        }
    };

    // Basic Data (Full 22 cards) / åŸºç¡€æ•°æ® (å®Œæ•´22å¼ )
    const RWS_DATA = [
        { id: 0,  en: { name: "The Fool", meaning: "New beginnings, innocence, spontaneity" }, zh: { name: "æ„šè€…", meaning: "æ–°çš„å¼€å§‹ï¼Œå¤©çœŸï¼Œè‡ªå‘æ€§ï¼Œå†’é™©" } },
        { id: 1,  en: { name: "The Magician", meaning: "Manifestation, resourcefulness, power" }, zh: { name: "é­”æœ¯å¸ˆ", meaning: "æ˜¾åŒ–ï¼Œèµ„æºä¸°å¯Œï¼ŒåŠ›é‡ï¼Œåˆ›é€ åŠ›" } },
        { id: 2,  en: { name: "High Priestess", meaning: "Intuition, sacred knowledge" }, zh: { name: "å¥³ç¥­å¸", meaning: "ç›´è§‰ï¼Œç¥åœ£çŸ¥è¯†ï¼Œæ½œæ„è¯†ï¼Œç¥ç§˜" } },
        { id: 3,  en: { name: "The Empress", meaning: "Femininity, beauty, nature" }, zh: { name: "çš‡å", meaning: "å¥³æ€§åŠ›é‡ï¼Œç¾ä¸½ï¼Œè‡ªç„¶ï¼Œå­•è‚²" } },
        { id: 4,  en: { name: "The Emperor", meaning: "Authority, establishment" }, zh: { name: "çš‡å¸", meaning: "æƒå¨ï¼Œä½“åˆ¶ï¼Œç»“æ„ï¼Œæ§åˆ¶" } },
        { id: 5,  en: { name: "The Hierophant", meaning: "Spiritual wisdom, beliefs" }, zh: { name: "æ•™çš‡", meaning: "ç²¾ç¥æ™ºæ…§ï¼Œä¿¡ä»°ï¼Œä¼ ç»Ÿï¼Œæ•™å¯¼" } },
        { id: 6,  en: { name: "The Lovers", meaning: "Love, harmony, choices" }, zh: { name: "æ‹äºº", meaning: "çˆ±ï¼Œå’Œè°ï¼Œå…³ç³»ï¼Œé€‰æ‹©" } },
        { id: 7,  en: { name: "The Chariot", meaning: "Control, willpower, success" }, zh: { name: "æˆ˜è½¦", meaning: "æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼ŒæˆåŠŸï¼Œè¡ŒåŠ¨" } },
        { id: 8,  en: { name: "Strength", meaning: "Strength, courage, persuasion" }, zh: { name: "åŠ›é‡", meaning: "åŠ›é‡ï¼Œå‹‡æ°”ï¼Œè¯´æœï¼Œå½±å“åŠ›" } },
        { id: 9,  en: { name: "The Hermit", meaning: "Soul-searching, introspection" }, zh: { name: "éšå£«", meaning: "æ¢ç´¢å†…å¿ƒï¼Œå†…çœï¼Œç‹¬å¤„ï¼ŒæŒ‡å¼•" } },
        { id: 10, en: { name: "Wheel of Fortune", meaning: "Good luck, karma, destiny" }, zh: { name: "å‘½è¿ä¹‹è½®", meaning: "å¥½è¿ï¼Œä¸šåŠ›ï¼Œç”Ÿå‘½å‘¨æœŸï¼Œå‘½è¿" } },
        { id: 11, en: { name: "Justice", meaning: "Justice, fairness, truth" }, zh: { name: "æ­£ä¹‰", meaning: "æ­£ä¹‰ï¼Œå…¬å¹³ï¼ŒçœŸç†ï¼Œå› æœ" } },
        { id: 12, en: { name: "Hanged Man", meaning: "Pause, surrender, letting go" }, zh: { name: "å€’åŠäºº", meaning: "æš‚åœï¼Œè‡£æœï¼Œæ”¾æ‰‹ï¼Œæ–°è§†è§’" } },
        { id: 13, en: { name: "Death", meaning: "Endings, change, transformation" }, zh: { name: "æ­»ç¥", meaning: "ç»“æŸï¼Œæ”¹å˜ï¼Œè½¬åŒ–ï¼Œè¿‡æ¸¡" } },
        { id: 14, en: { name: "Temperance", meaning: "Balance, moderation, patience" }, zh: { name: "èŠ‚åˆ¶", meaning: "å¹³è¡¡ï¼Œé€‚åº¦ï¼Œè€å¿ƒï¼Œç›®æ ‡" } },
        { id: 15, en: { name: "The Devil", meaning: "Shadow self, addiction" }, zh: { name: "æ¶é­”", meaning: "é˜´æš—é¢ï¼Œæ‰§ç€ï¼Œæˆç˜¾ï¼ŒæŸç¼š" } },
        { id: 16, en: { name: "The Tower", meaning: "Sudden change, upheaval" }, zh: { name: "é«˜å¡”", meaning: "çªå˜ï¼Œå‰§å˜ï¼Œæ··ä¹±ï¼Œå¯ç¤º" } },
        { id: 17, en: { name: "The Star", meaning: "Hope, faith, renewal" }, zh: { name: "æ˜Ÿæ˜Ÿ", meaning: "å¸Œæœ›ï¼Œä¿¡å¿µï¼Œç›®æ ‡ï¼Œæ–°ç”Ÿ" } },
        { id: 18, en: { name: "The Moon", meaning: "Illusion, fear, anxiety" }, zh: { name: "æœˆäº®", meaning: "å¹»è§‰ï¼Œææƒ§ï¼Œç„¦è™‘ï¼Œæ½œæ„è¯†" } },
        { id: 19, en: { name: "The Sun", meaning: "Positivity, fun, warmth" }, zh: { name: "å¤ªé˜³", meaning: "ç§¯æï¼Œå¿«ä¹ï¼Œæ¸©æš–ï¼ŒæˆåŠŸ" } },
        { id: 20, en: { name: "Judgement", meaning: "Judgement, rebirth, calling" }, zh: { name: "å®¡åˆ¤", meaning: "å®¡åˆ¤ï¼Œé‡ç”Ÿï¼Œå†…å¿ƒå¬å”¤ï¼Œèµ¦å…" } },
        { id: 21, en: { name: "The World", meaning: "Completion, integration" }, zh: { name: "ä¸–ç•Œ", meaning: "å®Œæˆï¼Œæ•´åˆï¼Œæˆå°±ï¼Œåœ†æ»¡" } }
    ];


    let currentLang = 'en';
    // If mobile, default to Mouse/Touch mode / å¦‚æœæ˜¯æ‰‹æœºï¼Œé»˜è®¤ä½¿ç”¨ Mouse/Touch æ¨¡å¼
    let controlMode = isMobile ? 'mouse' : 'hand';
    let isStarted = false;
    let deckList = [];

    // --- New: Physics Engine Variables / æ–°å¢ï¼šç‰©ç†å¼•æ“å˜é‡ ---
    let touchStartX = 0;      // Touch start position / è§¦æ‘¸èµ·å§‹ä½ç½®
    let lastTouchX = 0;       // Position in last frame / ä¸Šä¸€å¸§çš„ä½ç½®
    let touchVelocity = 0;    // Current slide velocity / å½“å‰æ»‘åŠ¨é€Ÿåº¦
    let isDragging = false;   // Is finger on screen / æ˜¯å¦æ‰‹æŒ‡æŒ‰åœ¨å±å¹•ä¸Š
    let isInertia = false;    // Is in inertia state / æ˜¯å¦å¤„äºæƒ¯æ€§æ»‘è¡ŒçŠ¶æ€
    const FRICTION = 0.95;    // Friction (0.9-0.99, higher slides further) / æ‘©æ“¦åŠ›
    const GRAB_THRESHOLD = 0.005; // Grab speed threshold (lower = stricter stop required) / æŠ“å–é€Ÿåº¦é˜ˆå€¼
    let interactionLock = false; // Interaction lock / äº¤äº’é”ï¼šé˜²æ­¢é•¿æŒ‰è¿å‘
    let holdTimer = null;    // Timer ID for long press / å­˜é•¿æŒ‰çš„é—¹é’ŸID
    let hasRevealed = false; // Flag: Was reveal successful? / æ ‡è®°ï¼šè¿™æ¬¡é•¿æŒ‰æ˜¯å¦å·²ç»æˆåŠŸæ­ç¤ºäº†

    // --- New: Interaction State Variables / æ–°å¢ï¼šäº¤äº’çŠ¶æ€å˜é‡ ---
    let dragDirection = null; // 'X' (Rotate) or 'Y' (Pull) / 'X' (æ—‹è½¬) æˆ– 'Y' (ä¸‹æ‹‰)
    let pullProgress = 0;     // Pull progress (0.0 ~ 1.0) / ä¸‹æ‹‰è¿›åº¦
    const PULL_THRESHOLD = 150; // Pixels to pull to confirm flip / ä¸‹æ‹‰å¤šå°‘åƒç´ ç®—ç¡®è®¤ç¿»ç‰Œ
    let isCoolingDown = false; // Global cooldown lock / å…¨å±€å†·å´é”
    const COOLDOWN_TIME = 300; // Cooldown time (ms) / å†·å´æ—¶é—´ (æ¯«ç§’)


    // Game Logic Params
    const MAX_SELECTION = 3;
    let selectionCount = 0;
    let isRitualComplete = false;
    let chosen3DMeshes = [];


    const RADIUS = 10;
    const CARD_W = 1.5;
    const CARD_H = 2.58;
    const CORNER_R = 0.08;
    const GOLD_COLOR = 0xd4af37;
    const BG_COLOR = 0x000000;

    let userQuestionText = ""; // Store user's question / å­˜å‚¨ç”¨æˆ·çš„é—®é¢˜

    // Initialize button states / åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
    window.onload = function() {
        setInput(controlMode);
        updateStartScreenText();
    };

    function setLang(lang) {
        currentLang = lang;
        document.querySelectorAll('[onclick^="setLang"]').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${lang}`).classList.add('active');
        updateStartScreenText();
    }

    function setInput(mode) {
        controlMode = mode;
        document.querySelectorAll('[onclick^="setInput"]').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${mode}`).classList.add('active');
    }

    function updateStartScreenText() {
        const t = TEXTS[currentLang];
        document.getElementById('subtitle').innerText = t.subtitle;
        document.getElementById('lbl-language').innerText = t.lblLang;
        document.getElementById('lbl-input').innerText = t.lblInput;
        document.getElementById('enter-btn').innerText = t.enter;
        document.getElementById('restart-btn').innerText = t.restart;
        // Update button text / æ›´æ–°æŒ‰é’®æ–‡å­—
        document.getElementById('btn-hand').innerText = t.btnHand;
        document.getElementById('btn-mouse').innerText = t.btnMouse;
    }

    function enterExperience() {
        // ğŸ”´ [Mod] Play first track / [ä¿®æ”¹] æ’­æ”¾ç¬¬ä¸€é¦– (bgm1.mp3)
        switchMusic('bgm-intro');
        // 1. Hide start screen / éšè—åˆå§‹é¡µ
        const screen = document.getElementById('start-screen');
        screen.style.opacity = 0;
        screen.style.pointerEvents = 'none';
        setTimeout(() => { screen.style.display = 'none'; }, 1000);

        // ğŸ”´ [Remove] Do not init Camera/Mouse/Touch listeners here
        // Moved to submitQuestion
        // Only keep camera position update
        // ç§»åˆ° submitQuestion é‡Œå»ï¼Œè¿™é‡Œåªä¿ç•™ç›¸æœºä½ç½®æ›´æ–°
        updateCameraPos();

        // 2. Show question screen / æ˜¾ç¤ºæé—®é¡µ
        const inputScreen = document.getElementById('input-screen');
        inputScreen.style.display = 'flex';

        const t = TEXTS[currentLang];
        document.getElementById('input-prompt').innerText = t.inputPrompt;
        document.getElementById('user-question').placeholder = t.inputPlaceholder;
        document.getElementById('confirm-question-btn').innerText = t.btnBegin;

        setTimeout(() => {
            inputScreen.style.opacity = 1;
            document.getElementById('user-question').focus();
        }, 100);
    }

    function submitQuestion() {
        const inputField = document.getElementById('user-question');
        // ğŸ”´ [New] Blur input to close keyboard / [æ–°å¢] ä¸»åŠ¨è®©è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹ï¼Œè§¦å‘é”®ç›˜æ”¶èµ·
        inputField.blur();

        // ğŸ”´ [New] Force reset view / [æ–°å¢] å¼ºåˆ¶å¤ä½è§†å›¾ï¼Œé˜²æ­¢é¡µé¢å¡åœ¨åŠç©ºä¸­
        window.scrollTo(0, 0);
        document.body.scrollTop = 0;
        const val = inputField.value.trim();
        userQuestionText = val || (currentLang === 'zh' ? "æˆ‘çš„å‘½è¿æŒ‡å¼•" : "My general destiny");

        // 1. Hide question screen / éšè—æé—®é¡µ
        const inputScreen = document.getElementById('input-screen');
        inputScreen.style.opacity = 0;
        // ğŸ”´ [Mod] Stop music (or keep playing if desired) / [ä¿®æ”¹] åœæ­¢æ‰€æœ‰éŸ³ä¹
        switchMusic(null);
        setTimeout(() => { inputScreen.style.display = 'none'; }, 1000);

        // 2. Start Logic / æ­£å¼å¼€å§‹é€»è¾‘
        isStarted = true;
        const ui = document.getElementById('ui-layer');
        ui.style.opacity = 1;

        updateStatusText();
        spawnDeck(); // Generate cards first! / å…ˆç”Ÿæˆå¡ç‰Œï¼

        // ğŸŸ¢ [New] Only init controls after deck spawn / [æ–°å¢] åªæœ‰å¡ç‰Œç”Ÿæˆäº†ï¼Œæ‰å…è®¸åˆå§‹åŒ–æ§åˆ¶
        // Prevent "divide by zero" errors / è¿™æ ·å°±ä¸ä¼šå‡ºç°â€œé™¤ä»¥é›¶â€çš„é”™è¯¯äº†
        if (controlMode === 'hand') {
            document.getElementById('video-feed').style.opacity = 0.3;
            initCamera();
        } else {
            initMouseListeners();
            initTouchListeners();
            initHUDListeners(); // Don't forget HUD listeners / åˆ«å¿˜äº† HUD ç›‘å¬
        }

        // Show guides / æ˜¾ç¤ºæŒ‡å¼•
        toggleGuides(true);
    }

    /**
     * THREE.JS SCENE SETUP
     */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(BG_COLOR);
    scene.fog = new THREE.FogExp2(BG_COLOR, 0.012);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    // Initial position determined by updateCameraPos / åˆå§‹ä½ç½®ç”± updateCameraPos å†³å®š

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const texLoader = new THREE.TextureLoader();
    // âš ï¸ Static Asset Loading: Load local images directly, bypass proxy
    // âš ï¸ é™æ€èµ„æºåŠ è½½ï¼šç›´æ¥åŠ è½½æœ¬åœ°å›¾ç‰‡ï¼Œä¸èµ°ä»£ç†
    const texBackGlobal = texLoader.load('./cards/back.png');
    texBackGlobal.anisotropy = renderer.capabilities.getMaxAnisotropy();
    texBackGlobal.center.set(0.5, 0.5);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    const frontLight = new THREE.DirectionalLight(0xffeaac, 0.6);
    frontLight.position.set(0, 2, 5);
    scene.add(frontLight);

    // Stars
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(2500 * 3);
    for (let i = 0; i < 2500; i++) {
        const r = 20 + Math.random() * 40;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        starPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        starPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        starPos[i * 3 + 2] = r * Math.cos(phi);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xcccccc, size: 0.06 });
    const starSystem = new THREE.Points(starGeo, starMat);
    scene.add(starSystem);

    /**
     * DECK CONSTRUCTION
     */
    const deckGroup = new THREE.Group();
    scene.add(deckGroup);
    let cardObjects = [];

    const shape = new THREE.Shape();
    const w = CARD_W / 2, h = CARD_H / 2, r = CORNER_R;
    shape.moveTo(-w + r, -h); shape.lineTo(w - r, -h); shape.quadraticCurveTo(w, -h, w, -h + r);
    shape.lineTo(w, h - r); shape.quadraticCurveTo(w, h, w - r, h);
    shape.lineTo(-w + r, h); shape.quadraticCurveTo(-w, h, -w, h - r);
    shape.lineTo(-w, -h + r); shape.quadraticCurveTo(-w, -h, -w + r, -h);
    const faceGeo = new THREE.ShapeGeometry(shape);

    function fixUVs(geometry) {
        const posAttribute = geometry.attributes.position;
        const uvAttribute = geometry.attributes.uv;
        for (let i = 0; i < posAttribute.count; i++) {
            const x = posAttribute.getX(i);
            const y = posAttribute.getY(i);
            uvAttribute.setXY(i, (x / CARD_W) + 0.5, (y / CARD_H) + 0.5);
        }
        uvAttribute.needsUpdate = true;
    }
    fixUVs(faceGeo);

    const matBase = { roughness: 0.6, metalness: 0.1 };
    const edgeMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, ...matBase });
    const outlineGeo = new THREE.EdgesGeometry(faceGeo);
    const outlineMat = new THREE.LineBasicMaterial({ color: GOLD_COLOR, linewidth: 2 });

    function createCardMesh(data, index, total) {
        const group = new THREE.Group();
        // âš ï¸ Load texture from local path / è¿™é‡ŒåŠ è½½å¡ç‰Œçº¹ç†ï¼šä½¿ç”¨æœ¬åœ°ç›¸å¯¹è·¯å¾„ï¼Œä¸èµ°ä»£ç†
        const texFront = texLoader.load(data.url);
        texFront.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texFront.center.set(0.5, 0.5);

        const matBack = new THREE.MeshStandardMaterial({ map: texBackGlobal, ...matBase });
        const matFront = new THREE.MeshStandardMaterial({ map: texFront, ...matBase });

        const meshBack = new THREE.Mesh(faceGeo, matBack);
        meshBack.position.z = 0.005;
        const meshFront = new THREE.Mesh(faceGeo, matFront);
        meshFront.rotation.y = Math.PI;
        meshFront.position.z = -0.005;
        const meshFiller = new THREE.Mesh(faceGeo, edgeMat);
        meshFiller.scale.set(0.995, 0.995, 1);

        group.add(meshBack, meshFront, meshFiller);

        const step = (Math.PI * 2) / total;
        const theta = index * step;
        group.position.x = RADIUS * Math.sin(theta);
        group.position.z = -RADIUS * Math.cos(theta);
        group.lookAt(0, 0, 0);

        group.userData = { id: data.id, rawData: data, state: 'IDLE', theta: theta, isChosen: false };
        return group;
    }

    function spawnDeck() {
        if (!isStarted) return;
        // Check if portrait (mobile) / åˆ¤æ–­æ˜¯å¦æ˜¯ç«–å±ï¼ˆæ‰‹æœºï¼‰
        const isPortrait = window.innerHeight > window.innerWidth;

        // Set height / è®¾ç½®é«˜åº¦
        deckGroup.position.y = isPortrait ? 2.0 : 0;

        deckGroup.clear();
        cardObjects = [];

        // âš ï¸ Generate local path data / ç”Ÿæˆæœ¬åœ°è·¯å¾„æ•°æ®
        deckList = RWS_DATA.map(d => ({
            ...d,
            url: `./cards/${d.id}.png` // Relative path / ç›¸å¯¹è·¯å¾„ï¼Œæµè§ˆå™¨ç›´æ¥åŠ è½½
        }));

        deckList.sort(() => Math.random() - 0.5);

        deckList.forEach((item, i) => {
            const card = createCardMesh(item, i, deckList.length);
            deckGroup.add(card);
            cardObjects.push(card);
        });
        document.getElementById('loader').style.display = 'none';
    }

    /**
     * INTERACTION LOGIC
     */
    let handState = 'OPEN';
    let handX = 0;
    let ringRotation = 0;
    let activeCard = null;
    let centerCard = null;

    // --- Modified: Mouse Listeners with Speed Limit ---
    // --- ä¿®æ”¹åï¼šå¸¦é€Ÿåº¦é™åˆ¶çš„é¼ æ ‡ç›‘å¬ ---
    function initMouseListeners() {
        window.addEventListener('mousemove', (e) => {
            handX = (e.clientX / window.innerWidth) * 2 - 1;
        });

        window.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;

            // Basic Position Check / åŸºç¡€ä½ç½®æ£€æŸ¥
            const isHoveringCenter = Math.abs(handX) < 0.2;

            // ğŸ›‘ Core Mod: Speed Detection / æ ¸å¿ƒä¿®æ”¹ï¼šé€Ÿåº¦æ£€æµ‹
            // If dragging with inertia and speed is high -> disable click / å¦‚æœæ­£åœ¨æƒ¯æ€§æ»‘è¡Œï¼Œä¸”é€Ÿåº¦å¤ªå¿« -> ç¦æ­¢ç‚¹å‡»
            const isTooFast = isInertia && Math.abs(touchVelocity) > GRAB_THRESHOLD;

            if (isHoveringCenter && !isTooFast) {
                // Only allow brake here / åªæœ‰è¿™é‡Œæ‰å…è®¸åˆ¹è½¦
                if (isInertia) {
                    isInertia = false;
                    touchVelocity = 0;
                    snapToGrid();
                }
                handState = 'PINCH';
            }
            updateCursorIcon();
        });

        window.addEventListener('mouseup', () => {
            handState = 'OPEN';
            updateCursorIcon();
        });

        // Keyboard Logic remains same / é”®ç›˜é€»è¾‘ä¿æŒä¸å˜
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handState = 'FIST';
            updateCursorIcon();
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && handState === 'FIST') handState = 'PINCH';
            else if (e.code === 'Space') handState = 'OPEN';
            updateCursorIcon();
        });
    }

    function initTouchListeners() {
        const container = document.getElementById('canvas-container');

        // 1. Touch Start / è§¦æ‘¸å¼€å§‹
        container.addEventListener('touchstart', (e) => {
            // ğŸ›‘ Disable touch in Hand Gesture mode / å¦‚æœæ˜¯æ‘„åƒå¤´æ‰‹åŠ¿æ¨¡å¼ï¼Œç¦ç”¨è§¦æ§é€»è¾‘
            if (controlMode === 'hand') return;

            const touch = e.touches[0];
            isDragging = true;
            isInertia = false;
            touchVelocity = 0;
            touchStartX = touch.clientX;
            lastTouchX = touch.clientX;
            touchStartY = touch.clientY;
            dragDirection = null;
            pullProgress = 0;
        }, { passive: false });

        // 2. Touch Move / è§¦æ‘¸ç§»åŠ¨
        container.addEventListener('touchmove', (e) => {
            if (controlMode === 'hand') return; // ğŸ›‘ Disable / ç¦ç”¨
            e.preventDefault();
            if (!isDragging) return;

            const touch = e.touches[0];
            const dx = touch.clientX - touchStartX;
            const dy = touch.clientY - touchStartY;

            // --- A. Direction Check / æ–¹å‘åˆ¤æ–­ ---
            if (!dragDirection) {
                if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        dragDirection = 'X';
                    } else if (dy > 0 && centerCard && selectionCount < MAX_SELECTION) {
                        dragDirection = 'Y';
                        isInertia = false;
                        touchVelocity = 0;
                        snapToGrid();
                        if (!activeCard) selectCard(centerCard);
                    }
                }
            }

            // --- B. Execution Logic / æ‰§è¡Œé€»è¾‘ ---
            if (dragDirection === 'X') {
                const currentX = touch.clientX;
                const deltaX = currentX - lastTouchX;
                lastTouchX = currentX;
                touchVelocity = deltaX * 0.005;
                ringRotation += touchVelocity * 3.0;
                deckGroup.rotation.y = ringRotation;
            } else if (dragDirection === 'Y') {
                let progress = dy / PULL_THRESHOLD;
                progress = Math.min(Math.max(progress, 0), 1.2);
                pullProgress = progress;
                if (activeCard) updatePullingVisuals(activeCard, progress);
            }
        }, { passive: false });

        // 3. Touch End / è§¦æ‘¸ç»“æŸ
        container.addEventListener('touchend', (e) => {
            if (controlMode === 'hand') return; // ğŸ›‘ Disable / ç¦ç”¨
            isDragging = false;

            if (dragDirection === 'X') {
                if (Math.abs(touchVelocity) > 0.002) isInertia = true;
                else snapToGrid();
            } else if (dragDirection === 'Y') {
                if (pullProgress > 0.8) {
                    if (activeCard) revealCard(activeCard);
                } else {
                    if (activeCard) returnCard(activeCard);
                }
                pullProgress = 0;
            }
            dragDirection = null;
        });
    }

    // --- Helper: Visuals for Pulling / è¾…åŠ©ï¼šä¸‹æ‹‰æ—¶çš„è§†è§‰è®¡ç®— ---
    function updatePullingVisuals(card, progress) {
        // Target Position Calculation:
        // Z: Pull from (-RADIUS) to near eye (-2.2)
        // Y: Lower slightly as pulled
        // ç›®æ ‡ä½ç½®è®¡ç®—ï¼š
        // Zè½´ï¼šä»åŸä½ (-RADIUS) æ‹‰è¿‘åˆ°çœ¼å‰ (-2.2)
        // Yè½´ï¼šéšç€ä¸‹æ‹‰ï¼Œç¨å¾®å¾€ä¸‹æ²‰ä¸€ç‚¹ç‚¹ï¼Œç¬¦åˆç‰©ç†ç›´è§‰

        // 0% Position (On Axis) / 0% çš„ä½ç½® (åœ¨ä¸­è½´ä¸Š)
        const startZ = -RADIUS;
        const startY = 0;

        // 100% Position (Confirmed) / 100% çš„ä½ç½® (çœ¼å‰ç¡®è®¤ä½)
        const endZ = isMobile ? -1.8 : -1.5;
        const endY = 0; // Slightly lower / æ‹‰åˆ°å±å¹•ä¸‹æ–¹ä¸€ç‚¹

        // Interpolation / æ’å€¼è®¡ç®—
        const currentZ = THREE.MathUtils.lerp(startZ, endZ, progress);
        const currentY = THREE.MathUtils.lerp(startY, endY, progress * 0.5); // Y axis moves less / Yè½´åŠ¨å°‘ä¸€ç‚¹

        // Rotation: Tilt slightly during pull / æ—‹è½¬ï¼šä¸‹æ‹‰è¿‡ç¨‹ä¸­ï¼Œå¡ç‰‡å¯ä»¥ç¨å¾®ç¿˜èµ·ä¸€ç‚¹ (Xè½´æ—‹è½¬)
        const targetRotX = progress * 0.5; // Slight tilt up / å¾®å¾®æŠ¬å¤´

        card.position.set(0, currentY, currentZ);
        card.rotation.x = targetRotX;

        // Temporarily take over rotation / æ­¤æ—¶æˆ‘ä»¬è¦æš‚æ—¶æ¥ç®¡ rotationï¼Œé˜²æ­¢ handleInput é‡Œçš„ lerp æ‰“æ¶
        card.userData.isManualDragging = true;
    }

    // --- New: UI Visibility Control / æ–°å¢ï¼šUI æ˜¾éšæ§åˆ¶å‡½æ•° ---
    function toggleGuides(show) {
        const axis = document.getElementById('axis-markers');
        const hud = document.getElementById('hud-center');

        // Axis line: semitransparent(0.4) vs hidden(0) / ä¸­è½´çº¿å¹³æ—¶æ˜¯åŠé€æ˜(0.4)ï¼Œéšè—æ—¶æ˜¯0
        axis.style.transition = 'opacity 0.5s';
        axis.style.opacity = show ? '0.4' : '0';

        // HUD: visible(1) vs hidden(0) / HUDå¹³æ—¶æ˜¯1ï¼Œéšè—æ—¶æ˜¯0
        hud.style.transition = 'opacity 0.5s';
        hud.style.opacity = show ? '1' : '0';

        // Disable clicks when hidden / éšè—æ—¶ç¦ç”¨ç‚¹å‡»ï¼Œé˜²æ­¢è¯¯è§¦
        hud.style.pointerEvents = show ? 'auto' : 'none';
    }

    // ==========================================
    // Music Control System (Dual Track)
    // éŸ³ä¹æ§åˆ¶ç³»ç»Ÿ (åŒéŸ³è½¨ç‰ˆ)
    // ==========================================

    let currentAudioId = null; // Current track ('bgm-intro' or 'bgm-final') / å½“å‰åº”è¯¥æ’­æ”¾å“ªé¦–
    let isGlobalMuted = false; // Global mute state / å…¨å±€é™éŸ³çŠ¶æ€

    // 1. Core Switch Function / åˆ‡æ¢éŸ³è½¨æ ¸å¿ƒå‡½æ•°
    function switchMusic(newId) {
        // Stop all music first / å…ˆåœæ­¢æ‰€æœ‰éŸ³ä¹
        document.getElementById('bgm-intro').pause();
        document.getElementById('bgm-final').pause();

        // If null, mute/stop / å¦‚æœä¼ å…¥ nullï¼Œè¯´æ˜è¦é™éŸ³/åœæ­¢
        if (!newId) {
            currentAudioId = null;
            updateMusicBtnState(false); // Stop rotation / æŒ‰é’®åœæ­¢æ—‹è½¬
            return;
        }

        currentAudioId = newId;
        const audio = document.getElementById(newId);
        audio.currentTime = 0; // From start / ä»å¤´å¼€å§‹
        audio.volume = 0.5;    // Set volume / è®¾ç½®éŸ³é‡

        // Play if not muted / å¦‚æœç”¨æˆ·æ²¡æœ‰æ‰‹åŠ¨é™éŸ³ï¼Œå°±å¼€å§‹æ’­æ”¾
        if (!isGlobalMuted) {
            audio.play().catch(e => console.log("Waiting for interaction to play / ç­‰å¾…äº¤äº’æ’­æ”¾"));
            updateMusicBtnState(true); // Start rotation / æŒ‰é’®å¼€å§‹æ—‹è½¬
        } else {
            updateMusicBtnState(false); // Keep muted icon / ä¿æŒé™éŸ³å›¾æ ‡
        }
    }

    // 2. User Click Toggle / ç”¨æˆ·ç‚¹å‡»å³ä¸Šè§’æŒ‰é’®
    function toggleMusic() {
        const btn = document.getElementById('music-control');
        isGlobalMuted = !isGlobalMuted; // Toggle State / åˆ‡æ¢çŠ¶æ€

        if (currentAudioId) {
            const audio = document.getElementById(currentAudioId);
            if (isGlobalMuted) {
                audio.pause();
                updateMusicBtnState(false);
            } else {
                audio.play();
                updateMusicBtnState(true);
            }
        }
    }

    // 3. Update Button UI (Helper) / æ›´æ–°æŒ‰é’®UI (è¾…åŠ©å‡½æ•°)
    function updateMusicBtnState(isPlaying) {
        const btn = document.getElementById('music-control');
        if (isPlaying) {
            btn.classList.remove('muted');
        } else {
            btn.classList.add('muted');
        }
    }

    // --- Modified: Clean Button Listeners / ä¿®æ”¹åï¼šå›å½’æœ¬è´¨çš„æŒ‰é’®ç›‘å¬ ---
    function initHUDListeners() {
        const hud = document.getElementById('hud-center');

        // Press = "I am pinching" / æŒ‰ä¸‹ = å‘Šè¯‰ç³»ç»Ÿâ€œæˆ‘ç°åœ¨æ˜¯æåˆçŠ¶æ€â€
        const onPress = (e) => {
            if (!isMobile) return;
            e.preventDefault();
            e.stopPropagation();

            // 1. Speed Check / é€Ÿåº¦æ£€æŸ¥ï¼šå¤ªå¿«äº†ä¸è®¸æŒ‰
            if (isInertia && Math.abs(touchVelocity) > GRAB_THRESHOLD) return;

            // 2. Count Check / æ•°é‡æ£€æŸ¥ï¼šé€‰å¤Ÿäº†ä¸è®¸æŒ‰
            if (selectionCount >= MAX_SELECTION) return;

            // 3. Action: Force Stop / åŠ¨ä½œï¼šå¼ºåˆ¶åœè½¦ï¼ŒçŠ¶æ€è®¾ä¸º PINCH
            isInertia = false;
            touchVelocity = 0;
            isDragging = false;
            snapToGrid();

            handState = 'PINCH'; // <--- Key: Change state only / å…³é”®ï¼šåªæ”¹å˜çŠ¶æ€ï¼Œå‰©ä¸‹çš„äº¤ç»™ä¸»å¾ªç¯
            updateCursorIcon();
        };

        // Release = "I let go" / æ¾å¼€ = å‘Šè¯‰ç³»ç»Ÿâ€œæˆ‘ç°åœ¨æ¾æ‰‹äº†â€
        const onRelease = (e) => {
            if (!isMobile) return;
            e.preventDefault();

            handState = 'OPEN'; // <--- Key: Reset state / å…³é”®ï¼šçŠ¶æ€å¤ä½
            updateCursorIcon();

            // Unlock rapid fire / è§£å¼€è¿å‘é”ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡æ“ä½œ
            interactionLock = false;
        };

        hud.addEventListener('touchstart', onPress, { passive: false });
        hud.addEventListener('touchend', onRelease, { passive: false });
        hud.addEventListener('touchcancel', onRelease, { passive: false });
    }


    function updateCursorIcon() {
        const icon = handState === 'FIST' ? 'âœŠ' : (handState === 'PINCH' ? 'ğŸ¤' : (isMobile ? 'ğŸ‘†' : 'ğŸ–±ï¸'));
        document.getElementById('gesture-icon').innerText = icon;
    }

    function updateStatusText() {
        const t = TEXTS[currentLang];
        const el = document.getElementById('status-text');
        if (isRitualComplete) {
            el.innerText = t.statusDone;
            return;
        }
        if (activeCard && activeCard.userData.state === 'SELECTED') {
            el.innerText = controlMode === 'hand' ? t.statusFist : t.statusSpace;
        } else if (activeCard && activeCard.userData.state === 'REVEALING') {
            el.innerText = t.statusReveal;
        } else {
            if (controlMode === 'hand') el.innerText = t.statusWave;
            else el.innerText = isMobile ? t.statusTouch : t.statusMouse; // Different hints / åŒºåˆ†è§¦æ‘¸å’Œé¼ æ ‡æç¤º
        }
    }

    // --- Define: Core Axis Calculation / å®šä¹‰ï¼šæ ¸å¿ƒä¸­è½´è®¡ç®—é€»è¾‘ ---
    // --- Modified: With Freeze Logic / ä¿®æ”¹åï¼šå¸¦å†»ç»“é€»è¾‘çš„ä¸­è½´åˆ¤å®š ---
    function getAxisCard() {
        // ğŸ›‘ Freeze Logic (Step 8.1) / å†»ç»“é€»è¾‘
        // If there is currently a "Hero Card" (Selected, Pulling, or Returning)
        // Lock it as axis card, ignore distance calculation
        // å¦‚æœå½“å‰æœ‰â€œä¸»è§’å¡â€ (é€‰ä¸­ã€ä¸‹æ‹‰ä¸­ã€æˆ–æ­£åœ¨å½’ä½)ï¼Œç›´æ¥é”å®šå®ƒä¸ºä¸­è½´å¡
        if (activeCard) {
            // Ensure no outline (we use lighting) / ç¡®ä¿å®ƒä¸é«˜äº®è½®å»“ï¼ˆæˆ‘ä»¬ç”¨å…‰å½±æè´¨æ¥åšé«˜äº®ï¼‰
            if (activeCard.userData.outline) activeCard.userData.outline.visible = false;
            return activeCard;
        }

        // --- Standard Logic (Run only when no card selected) / ä»¥ä¸‹æ˜¯å¸¸è§„é€»è¾‘ ---

        let closestCard = null;
        let minAbsX = Infinity;

        cardObjects.forEach(card => {
            // Exclude chosen cards / æ’é™¤å·²é€‰ä¸­çš„
            if (card.userData.isChosen) return;

            // Get World X / è·å–ä¸–ç•Œåæ ‡ X
            const worldPos = new THREE.Vector3();
            card.getWorldPosition(worldPos);

            // Only consider cards in front / åªçœ‹ç›¸æœºå‰æ–¹çš„å¡
            if (worldPos.z < 0) {
                const absX = Math.abs(worldPos.x);
                if (absX < minAbsX) {
                    minAbsX = absX;
                    closestCard = card;
                }
            }

            // Ensure no outline / ç¡®ä¿å¹³æ—¶æ²¡æœ‰ outline
            if (card.userData.outline) card.userData.outline.visible = false;
        });

        return closestCard;
    }

    let isHandRotating = false; // New Flag / æ–°å¢æ ‡è®°

    function handleInput() {
        if (!isStarted) return;
        if (isRitualComplete) {
            animateFinalFormation();
            return;
        }

        // ğŸ›‘ Cooldown Lock / å†·å´æœŸé”æ­»
        if (isCoolingDown) return;

        // ==========================================
        // 1. Physics Engine (Run only when no card selected)
        // 1. ç‰©ç†å¼•æ“ (ä»…å½“æ²¡é€‰ä¸­ç‰Œï¼Œä¸”ä¸åœ¨ä¸‹æ‹‰æŠ½å¡æ—¶è¿è¡Œ)
        // ==========================================
        if (!activeCard) {
            if (isInertia) {
                ringRotation += touchVelocity * 15;
                touchVelocity *= FRICTION;
                if (Math.abs(touchVelocity) < 0.0005) {
                    isInertia = false;
                    touchVelocity = 0;
                    snapToGrid();
                }
            }

            // Compatible with PC Mouse / Camera Gesture Rotation / å…¼å®¹ PCé¼ æ ‡ / æ‘„åƒå¤´æ‰‹åŠ¿è½¬åŠ¨
            if (!isDragging && !isInertia && handState === 'OPEN') {
                const deadZone = 0.15;
                const speed = isMobile ? 0.015 : 0.02;
                if (Math.abs(handX) > deadZone) {
                    ringRotation += (handX - Math.sign(handX) * deadZone) * speed;
                    isHandRotating = true;
                } else if (isHandRotating) {
                    snapToGrid();
                    isHandRotating = false;
                }
            }

            // Apply Rotation / åº”ç”¨æ—‹è½¬
            if (isDragging && dragDirection === 'X') {
                deckGroup.rotation.y = ringRotation;
            } else {
                deckGroup.rotation.y = THREE.MathUtils.lerp(deckGroup.rotation.y, ringRotation, 0.1);
            }
        }

        // ==========================================
        // 2. Axis Calculation / ä¸­è½´è®¡ç®—
        // ==========================================
        const newAxisCard = getAxisCard();
        centerCard = newAxisCard;

        // PC Mouse Feedback / PC é¼ æ ‡æ ·å¼åé¦ˆ
        if (!isMobile && !isDragging) {
            if (Math.abs(handX) < 0.2 && centerCard && !isInertia) document.body.classList.add('can-grab');
            else document.body.classList.remove('can-grab');
        }

        // ==========================================
        // 3. Grab Logic (Trigger Selection) / æŠ“å–é€»è¾‘
        // ==========================================

        // If PINCH, Axis Card exists, No Active Card, Not Dragging, Not Inertia, Not Pulling
        // åªè¦ handState æ˜¯ PINCHï¼Œä¸”æœ‰ä¸­è½´å¡ï¼Œæ²¡æŠ“åˆ«çš„ï¼Œä¸æ˜¯åœ¨ä¸‹æ‹‰ï¼Œä¸æ˜¯åœ¨æƒ¯æ€§
        if (handState === 'PINCH' && centerCard && !activeCard && !isDragging && !isInertia && dragDirection !== 'Y') {
            selectCard(centerCard);
        }

        // ==========================================
        // 4. Interaction after Selection / é€‰ä¸­åçš„äº¤äº’
        // ==========================================

        if (activeCard) {
            // --- A. Touch Pull Mode / è§¦æ§ä¸‹æ‹‰æ¨¡å¼ ---
            // Controlled by touchmove, no position interference here
            // å…¨æƒäº¤ç»™ touchmove æ§åˆ¶ï¼Œè¿™é‡Œä¸å¹²æ¶‰ä½ç½®
            if (dragDirection === 'Y') {
                if (activeCard.userData.outline) activeCard.userData.outline.visible = false;
            }

            // --- B. Auto Mode (Mouse / Camera) / è‡ªåŠ¨æ¨¡å¼ ---
            else {
                // 1. Basic Animation: Fly to Eye / åŸºç¡€åŠ¨ç”»ï¼šé£åˆ°çœ¼å‰
                const targetZ = isMobile ? -3.5 : -2.2;
                // ğŸ”´ [Mod] Mobile Height Correction / [ä¿®æ”¹è¿™é‡Œ] ç§»åŠ¨ç«¯é«˜åº¦ä¿®æ­£
                // 0 = World Center (Looks low on mobile) / ä¸–ç•Œä¸­å¿ƒ (ç§»åŠ¨ç«¯çœ‹èµ·æ¥åä¸‹)
                // 0.8 = Slightly raised / ç¨å¾®æŠ¬é«˜ (ç§»åŠ¨ç«¯çœ‹èµ·æ¥å±…ä¸­)
                const targetY = isMobile ? 0.8 : 0;

                // Move with interpolation / ä½¿ç”¨æ–°çš„ targetY è¿›è¡Œæ’å€¼ç§»åŠ¨
                activeCard.position.lerp(new THREE.Vector3(0, targetY, targetZ), 0.1);

                if (activeCard.userData.state === 'SELECTED') {
                    const idleQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0));
                    activeCard.quaternion.slerp(idleQ, 0.1);

                    // 2. ğŸš¨ Logic Branching / åˆ¤å®šé€»è¾‘åˆ†æµ ğŸš¨

                    // === âœ‹ Branch 1: Hand Mode / æ‰‹åŠ¿æ¨¡å¼ ===
                    if (controlMode === 'hand') {
                        // Rule: Fist to Flip / è§„åˆ™ï¼šä¸æ¡æ‹³ä¸ç¿»è½¬

                        if (handState === 'FIST') {
                            // Fist -> Reveal Immediately / æ¡æ‹³ -> ç«‹å³ç¿»è½¬
                            revealCard(activeCard);
                        } else if (handState === 'OPEN') {
                            // Release -> Return / æ¾æ‰‹ -> å¼¹å›
                            returnCard(activeCard);
                        }
                        // Note: If PINCH, do nothing (Hover)
                        // æ³¨æ„ï¼šå¦‚æœæ˜¯ PINCHï¼Œè¿™é‡Œä»€ä¹ˆéƒ½ä¸åšï¼Œæ‚¬åœã€‚
                    }

                    // === ğŸ–±ï¸ Branch 2: Mouse Mode / é¼ æ ‡æ¨¡å¼ ===
                    else {
                        // Rule: Long Press to Flip / è§„åˆ™ï¼šé•¿æŒ‰ç¿»è½¬

                        if (handState === 'PINCH') {
                            // Holding -> Timer / æŒ‰ä½é¼ æ ‡ -> è®¡æ—¶
                            if (!activeCard.userData.revealTimer) activeCard.userData.revealTimer = Date.now();

                            // > 500ms -> Flip / è¶…è¿‡ 500ms -> ç¿»è½¬
                            if (Date.now() - activeCard.userData.revealTimer > 500) {
                                revealCard(activeCard);
                            }
                        } else if (handState === 'OPEN') {
                            // Release -> Return / æ¾å¼€é¼ æ ‡ -> å¼¹å›
                            activeCard.userData.revealTimer = null;
                            returnCard(activeCard);
                        }
                    }
                }
            }
        } else {
            updateStatusText();
        }
    }

    // --- New: Force Snap to Grid / æ–°å¢ï¼šå¼ºåˆ¶å½’ä½é€»è¾‘ ---
    function snapToGrid() {
        if (deckList.length === 0) return;
        // 1. Calculate angle step / ç®—å‡ºæ¯å¼ ç‰Œçš„é—´éš”è§’åº¦ (å¼§åº¦)
        const step = (Math.PI * 2) / deckList.length;

        // 2. Find closest slot index / ç®—å‡ºå½“å‰æ—‹è½¬è§’åº¦å¯¹åº”çš„æ˜¯â€œç¬¬å‡ ä¸ªå¡ä½â€
        // Math.round creates the "Snap" effect / ä½¿ç”¨ Math.round è¿›è¡Œå››èˆäº”å…¥
        const closestIndex = Math.round(ringRotation / step);

        // 3. Calculate target angle / ç®—å‡ºé‚£ä¸ªå¡ä½çš„æ ‡å‡†è§’åº¦
        const targetRotation = closestIndex * step;

        // 4. Set rotation target (lerp handles movement) / ç³»ç»Ÿè®¤ä¸ºâ€œåº”è½¬åˆ°è¿™é‡Œâ€ï¼Œlerp ä¼šå¹³æ»‘å¤„ç†
        ringRotation = targetRotation;

        // 5. Update axis card / å†æ¬¡å¼ºåˆ¶æ›´æ–°ä¸€ä¸‹ä¸­è½´å¡
        centerCard = getAxisCard();
    }


    function selectCard(card) {
        if (selectionCount >= MAX_SELECTION) return;
        // [New] Hide guides on selection / [æ–°å¢] ä¸€æ—¦é€‰ä¸­ï¼Œç«‹å³éšè—æŒ‡å¼•å±‚
        toggleGuides(false);
        activeCard = card;
        card.userData.state = 'SELECTED';
        card.userData.revealTimer = Date.now(); // Init Timer / åˆå§‹åŒ–è®¡æ—¶å™¨
        if (card.userData.outline) card.userData.outline.visible = false;
        scene.attach(card);
    }

    function returnCard(card) {
        deckGroup.attach(card);
        card.userData.state = 'RETURNING';
        activeCard = null;
    }

    // --- Modified: Return with Cooldown / ä¿®æ”¹åï¼šå½’ä½åå¸¦æœ‰å†·å´æœŸ ---
    function updateReturningCards() {
        cardObjects.forEach(card => {
            if (card.userData.state === 'RETURNING') {
                // ... (Logic same as before) ...
                const targetPos = new THREE.Vector3(
                    RADIUS * Math.sin(card.userData.theta),
                    0,
                    -RADIUS * Math.cos(card.userData.theta)
                );
                card.position.lerp(targetPos, 0.08);

                // Simple rotation interpolation / ç®€å•çš„æ—‹è½¬æ’å€¼
                const dummy = new THREE.Object3D();
                dummy.position.copy(card.position);
                dummy.lookAt(0, 0, 0);
                card.quaternion.slerp(dummy.quaternion, 0.08);

                // ğŸ›‘ Arrival Check / åˆ°è¾¾åˆ¤æ–­
                if (card.position.distanceTo(targetPos) < 0.05) {
                    // 1. Physical Return / ç‰©ç†å½’ä½
                    deckGroup.attach(card);
                    card.position.set(
                        RADIUS * Math.sin(card.userData.theta),
                        0,
                        -RADIUS * Math.cos(card.userData.theta)
                    );
                    card.lookAt(0, 0, 0); // Correct Facing / ç¡®ä¿æœå‘æ­£ç¡®

                    // 2. Mark State Idle / æ ‡è®°çŠ¶æ€å·²å®Œæˆ
                    card.userData.state = 'IDLE';

                    // 3. ğŸ›‘ Core Mod: Enter Cooldown / æ ¸å¿ƒä¿®æ”¹ï¼šè¿›å…¥å†·å´æœŸ
                    isCoolingDown = true;

                    // 4. Delayed Unlock / å»¶è¿Ÿè§£é”
                    setTimeout(() => {
                        // Cooldown over / å†·å´ç»“æŸ
                        activeCard = null;
                        isCoolingDown = false;
                        // [New] Show guides if ritual not complete / [æ–°å¢] åªæœ‰å½“ä»ªå¼è¿˜æ²¡å½»åº•ç»“æŸæ—¶ï¼Œæ‰æ¢å¤æŒ‡å¼•æ˜¾ç¤º
                        if (!isRitualComplete && selectionCount < MAX_SELECTION) {
                            if (typeof toggleGuides === 'function') {
                                toggleGuides(true);
                            }
                        }
                    }, COOLDOWN_TIME);
                }
            }
        });
    }



    // --- Modified: Reveal with Freeze/Cooldown / ä¿®æ”¹åï¼šé…åˆå†»ç»“å’Œå†·å´çš„ç¿»ç‰Œé€»è¾‘ ---
    function revealCard(card) {
        // 1. Prevent Double Trigger / é˜²é‡å¤è§¦å‘
        if (card.userData.state === 'REVEALING') return;

        // 2. ğŸš¨ Key Mod: Change State / å…³é”®ä¿®æ”¹ï¼šæ”¹å˜çŠ¶æ€
        // Stops handleInput logic, allowing animateFlip to control / åœæ­¢è‡ªåŠ¨æ‰¶æ­£é€»è¾‘
        card.userData.state = 'REVEALING';

        updateStatusText(); // Update Text / æ›´æ–°åº•éƒ¨æ–‡å­—

        // 3. Determine Upright/Reversed / å†³å®šæ­£é€†ä½ (éšæœº)
        const isReversed = Math.random() < 0.5;
        card.userData.isReversed = isReversed;

        // 4. Calculate Target Rotation / è®¡ç®—ç¿»è½¬çš„ç›®æ ‡è§’åº¦
        const startQ = card.quaternion.clone();
        const targetEuler = new THREE.Euler(0, Math.PI, isReversed ? Math.PI : 0);
        const targetQ = new THREE.Quaternion().setFromEuler(targetEuler);

        // 5. Get Name / è·å–å¡å
        const data = card.userData.rawData;
        const name = data[currentLang].name;

        // 6. Execute Animation / æ‰§è¡Œç¿»è½¬åŠ¨ç”»
        let p = 0;

        function animateFlip() {
            p += 0.03; // Speed / ç¿»è½¬é€Ÿåº¦

            // Slerp / æ’å€¼æ—‹è½¬
            card.quaternion.slerpQuaternions(startQ, targetQ, p);

            if (p < 1) {
                requestAnimationFrame(animateFlip);
            } else {
                // End: Force Rotation / åŠ¨ç”»ç»“æŸï¼Œå¼ºåˆ¶ä¿®æ­£è§’åº¦
                card.rotation.set(0, Math.PI, isReversed ? Math.PI : 0);

                // Show Name / æ˜¾ç¤ºå¡ç‰Œåå­—
                document.getElementById('status-text').innerText = name.toUpperCase();

                // 7. â³ Wait 2s then Dissolve / åœç•™ 2ç§’ è®©ç”¨æˆ·çœ‹æ¸…ç‰Œé¢ï¼Œç„¶åæ‰§è¡Œæº¶è§£
                setTimeout(() => {
                    dissolve(card, isReversed);
                }, 2000);
            }
        }
        animateFlip();
    }

    // --- Modified: Dissolve with Cooldown / ä¿®æ”¹åï¼šç¿»ç‰Œåå¸¦æœ‰å†·å´æœŸ ---
    function dissolve(card, isReversed) {
        spawnParticles(card.position);
        selectionCount++;
        addToHistory(card.userData.rawData, isReversed);

        // Hide Card / éšè—å¡ç‰‡
        card.visible = false;
        card.userData.isChosen = true;
        chosen3DMeshes.push(card);

        // ğŸ›‘ Core Mod: Enter Cooldown / æ ¸å¿ƒä¿®æ”¹ï¼šè¿›å…¥å†·å´æœŸ
        isCoolingDown = true;

        // Delayed Unlock / å»¶è¿Ÿè§£é”
        setTimeout(() => {
            // Unlock Active Card / åªæœ‰å†·å´ç»“æŸåï¼Œæ‰é‡Šæ”¾ activeCard
            activeCard = null;
            isCoolingDown = false;

            // Check if End / æ£€æŸ¥æ˜¯å¦ç»“æŸ
            if (selectionCount >= MAX_SELECTION) {
                startEndRitual();
            } else {
                // ğŸŸ¢ [New] Show guides for next pick / [æ–°å¢] å¦‚æœè¿˜æ²¡é€‰å®Œ 3 å¼ ï¼Œå¿…é¡»æ¢å¤æ˜¾ç¤ºæŒ‡å¼•
                if (typeof toggleGuides === 'function') {
                    toggleGuides(true);
                }
            }
        }, COOLDOWN_TIME);
    }

    function startEndRitual() {
        isRitualComplete = true;
        updateStatusText();

        document.getElementById('history-container').style.opacity = 0;
        document.getElementById('hud-center').style.opacity = 0;

        setTimeout(() => {
            // Show End UI / æ˜¾ç¤ºåº•éƒ¨UI
            document.getElementById('end-ui').style.opacity = 1;
            document.getElementById('end-ui').style.pointerEvents = 'auto';
            document.getElementById('credits').style.opacity = 1;

            // --- Logic Change: Show Reveal Button, Hide Restart / é€»è¾‘å˜æ›´ï¼šå…ˆæ˜¾ç¤ºæŸ¥çœ‹æŒ‡å¼•æŒ‰é’®ï¼Œéšè—é‡å¯æŒ‰é’® ---
            document.getElementById('view-reading-btn').style.display = 'block';
            document.getElementById('restart-btn').style.display = 'none';

            // Set Language / è®¾ç½®æŒ‰é’®è¯­è¨€
            const btnText = currentLang === 'zh' ? "æ­ç¤ºæŒ‡å¼•" : "REVEAL FATE";
            document.getElementById('view-reading-btn').innerText = btnText;

        }, 3500);

        cardObjects.forEach(c => {
            if (!c.userData.isChosen) {
                c.userData.dropSpeed = 0.05 + Math.random() * 0.1;
            }
        });

        chosen3DMeshes.forEach((card, index) => {
            card.visible = true;
            scene.attach(card);
            // End Animation Start Pos / ç»“æŸåŠ¨ç”»èµ·å§‹ä½ç½®
            card.position.set(4 + index * 0.5, 3, -4);
            card.scale.set(0.2, 0.2, 0.2);

            // Responsive Final Pos / å“åº”å¼æœ€ç»ˆä½ç½®è®¡ç®—
            const isPortrait = window.innerHeight > window.innerWidth;
            const gap = isPortrait ? 1.8 : 3.0;
            const depth = isPortrait ? -7.0 : -6.0;
            const targetY = isPortrait ? 3.0 : 0;

            card.userData.finalTargetPos = new THREE.Vector3((index - 1) * gap, targetY, depth);
            card.userData.finalTargetScale = 0.8;
            card.userData.animProgress = 0;
            card.userData.animDelay = index * 30;
        });

        const textContainer = document.getElementById('final-text-container');
        const t = TEXTS[currentLang];

        chosen3DMeshes.forEach(card => {
            const div = document.createElement('div');
            div.className = 'final-card-label';
            const data = card.userData.rawData[currentLang];
            const revText = card.userData.isReversed ? ` (${t.rev})` : "";
            div.innerHTML = `<div class="final-name">${data.name}${revText}</div><div class="final-meaning">${data.meaning}</div>`;
            textContainer.appendChild(div);
        });
        setTimeout(() => { textContainer.style.opacity = 1; }, 2000);
    }

    // --- Modified: Enter Starry Void (Async API) / ä¿®æ”¹ï¼šè¿›å…¥æ˜Ÿç©ºè§£è¯´æ¨¡å¼ (æ”¯æŒå¼‚æ­¥ API) ---
    async function enterStarryVoid() {
        // ğŸ”´ [Mod] Play second track / [ä¿®æ”¹] æ’­æ”¾ç¬¬äºŒé¦– (bgm2.mp3)
        switchMusic('bgm-final');
        // Hide buttons / éšè—æŒ‰é’®å’Œæ ‡ç­¾
        document.getElementById('view-reading-btn').style.display = 'none';
        document.getElementById('final-text-container').style.opacity = 0;

        // Hide 3D Cards / éšè—æ‰€æœ‰3Då¡ç‰Œ
        chosen3DMeshes.forEach(mesh => { mesh.visible = false; });
        cardObjects.forEach(mesh => { mesh.visible = false; });

        const overlay = document.getElementById('oracle-overlay');

        // Show Loading / æ˜¾ç¤º Loading åŠ¨ç”»
        const loadingText = currentLang === 'zh' ? "æ­£åœ¨ä¸æ˜Ÿè¾°è¿æ¥..." : "Connecting with the stars...";
        overlay.innerHTML = `<div style="opacity:0.7; animation: pulse 1.5s infinite;">${loadingText}</div>`;

        // Callback after typing / å®šä¹‰æ‰“å­—ç»“æŸåçš„å›è°ƒå‡½æ•°
        const onTypingComplete = () => {
            const restartBtn = document.getElementById('restart-btn');
            restartBtn.style.display = 'block';
            restartBtn.style.opacity = 0;
            let op = 0;
            const fadeTimer = setInterval(() => {
                if (op >= 1) clearInterval(fadeTimer);
                restartBtn.style.opacity = op;
                op += 0.05;
            }, 30);
        };

        // Try Calling API / å°è¯•è°ƒç”¨ API
        if (API_KEY && API_KEY.length > 5) {
            try {
                const apiText = await callTarotAPI(chosen3DMeshes);
                typeWriter(apiText, overlay, onTypingComplete);
            } catch (e) {
                console.error("API Error:", e);

                // ğŸ”´ Debug: Alert on error / è°ƒè¯•æ¨¡å¼ï¼šå¼¹å‡ºé”™è¯¯è­¦å‘Š
                if (DEBUG_MODE) {
                    // Prompt user / æç¤ºç”¨æˆ·å®‰è£…æ’ä»¶
                    alert(`API è°ƒç”¨å¤±è´¥: ${e.message}\n\nã€è§£å†³æ–¹æ¡ˆã€‘\nAPI åœ¨æµè§ˆå™¨ç›´æ¥è°ƒç”¨æ—¶ä¼šè¢«æ‹¦æˆª (CORS Error)ã€‚\nè¯·ç¡®ä¿ä»£ç† URL æœ‰æ•ˆã€‚`);
                }

                // Fallback Text / å¤±è´¥åˆ™é™çº§åˆ°æœ¬åœ°æ–‡æ¡ˆ
                const fallbackText = generateReadingText();
                typeWriter(fallbackText, overlay, onTypingComplete);
            }
        } else {
            // No Key -> Local Logic / æ²¡æœ‰ Keyï¼Œç›´æ¥ä½¿ç”¨æœ¬åœ°é€»è¾‘
            setTimeout(() => {
                const text = generateReadingText();
                typeWriter(text, overlay, onTypingComplete);
            }, 1500);
        }
    }

    // --- New: Call LLM API (With Proxy) / æ–°å¢ï¼šè°ƒç”¨ LLM API è·å–è§£è¯» (åŒ…å« Proxy é€»è¾‘) ---
    async function callTarotAPI(cards) {
        const cardDescriptions = cards.map((c, i) => {
            const name = c.userData.rawData[currentLang].name;
            const posName = currentLang === 'zh' ? ["è¿‡å»", "ç°åœ¨", "æœªæ¥"][i] : ["Past", "Present", "Future"][i];
            const status = c.userData.isReversed
                ? (currentLang === 'zh' ? "é€†ä½ (Reversed)" : "Reversed")
                : (currentLang === 'zh' ? "æ­£ä½ (Upright)" : "Upright");
            return `${posName}: ${name} [${status}]`;
        }).join("\n");

        const prompt = currentLang === 'zh'
            ? `ä½ æ˜¯ä¸€ä½ç¥ç§˜çš„å¡”ç½—ç‰Œå åœå¸ˆã€‚æ±‚é—®è€…çš„é—®é¢˜æ˜¯ï¼šâ€œ${userQuestionText}â€ã€‚\nè¯·æ ¹æ®ä»¥ä¸‹ç‰Œé˜µä¸ºæ±‚é—®è€…è§£è¯»ï¼š\n${cardDescriptions}\n\nè¦æ±‚ï¼š\n1. ç”¨ä¸­æ–‡å›ç­”ã€‚\n2. å¿…é¡»ç»“åˆæ±‚é—®è€…çš„é—®é¢˜è¿›è¡Œè§£ç­”ã€‚\n3. é£æ ¼ç¥ç§˜ã€è¯—æ„ã€‚\n4. å°†ä¸‰å¼ ç‰Œä¸²è”æˆä¸€ä¸ªå®Œæ•´çš„æ•…äº‹ã€‚\n5. å­—æ•°æ§åˆ¶åœ¨150å­—ä»¥å†…ã€‚`
            : `You are a mystical Tarot reader. The seeker asks: "${userQuestionText}".\nInterpret the following spread:\n${cardDescriptions}\n\nRequirements:\n1. Answer in English.\n2. Directly address the seeker's question.\n3. Tone: Mystical, poetic.\n4. Weave the cards into a coherent narrative.\n5. Keep it under 150 words.`;
        // AbortController for Timeout / å¢åŠ  AbortController ç”¨äºè¶…æ—¶æ§åˆ¶
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000); // 20s Timeout / 20ç§’è¶…æ—¶

        // --- âš ï¸ Key Fix: Use Proxy Here / å…³é”®ä¿®æ­£ï¼šåªæœ‰è¿™é‡Œä½¿ç”¨ä»£ç† ---
        let url = API_ENDPOINT;
        if (USE_PROXY_FOR_API) {
            console.log("Applying proxy for CORS / æ­£åœ¨åº”ç”¨ä»£ç†ä»¥è§£å†³è·¨åŸŸé—®é¢˜...");
            // Append target API to proxy URL / å°†ç›®æ ‡ API åœ°å€ç¼–ç åæ‹¼æ¥åˆ°ä»£ç†åœ°å€åé¢
            url = PROXY_BASE_URL + encodeURIComponent(API_ENDPOINT);
        }
        // -------------------------------------

        try {
            // æ„å»ºè¯·æ±‚ä½“ï¼Œå…¼å®¹ç«å±±æ–¹èˆŸAIç½‘å…³çš„æ ¼å¼
            const requestBody = {
                model: API_MODEL,
                messages: [{
                    role: "user",
                    // ç«å±±æ–¹èˆŸæ”¯æŒcontentä¸ºå­—ç¬¦ä¸²æˆ–å¯¹è±¡æ•°ç»„
                    // å½“å‰éœ€æ±‚ä¸ºçº¯æ–‡æœ¬ï¼Œä½¿ç”¨å­—ç¬¦ä¸²æ ¼å¼å³å¯
                    content: prompt
                }],
                temperature: 0.7,
                max_tokens: 300
            };
            
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${API_KEY}`
                },
                body: JSON.stringify(requestBody),
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                const errText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errText}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        } catch (err) {
            clearTimeout(timeoutId);
            throw err;
        }
    }

    // --- Fallback: Local Reading / å¤‡é€‰ï¼šç”Ÿæˆæœ¬åœ°è§£è¯´æ–‡æ¡ˆ ---
    function generateReadingText() {
        const m1 = chosen3DMeshes[0].userData.rawData[currentLang].meaning;
        const m2 = chosen3DMeshes[1].userData.rawData[currentLang].meaning;
        const m3 = chosen3DMeshes[2].userData.rawData[currentLang].meaning;

        if (currentLang === 'zh') {
            return `å‘½è¿çš„è½¨è¿¹å·²åœ¨æ˜Ÿè¾°ä¸­æ˜¾ç°...<br><br>` +
                `è¿‡å»ï¼Œä½ ç»å†äº† ${m1}ã€‚<br>` +
                `æ­¤åˆ»ï¼Œæ­£å¦‚ ${m2} æ‰€æ˜­ç¤ºçš„ï¼Œä½ éœ€è¦ä¸“æ³¨äºå½“ä¸‹çš„åŠ›é‡ã€‚<br>` +
                `è€Œæœªæ¥ï¼Œ${m3} å°†ä¼šæ˜¯ä½ çš„æŒ‡å¼•ã€‚<br><br>` +
                `ç›¸ä¿¡ç›´è§‰ï¼Œæ‹¥æŠ±å˜åŒ–ã€‚`;
        } else {
            return `The stars have aligned to reveal your path...<br><br>` +
                `In the past, you walked through ${m1}.<br>` +
                `Presently, as shown by ${m2}, focus on your inner power.<br>` +
                `For the future, let ${m3} be your guiding light.<br><br>` +
                `Trust your intuition. Embrace the change.`;
        }
    }

    // --- Typewriter Effect / æ‰“å­—æœºç‰¹æ•ˆ ---
    function typeWriter(htmlText, element, callback) {
        element.innerHTML = "";
        const plainText = htmlText.replace(/<br>/g, '\n');
        let i = 0;
        const speed = 50;

        function type() {
            if (i < plainText.length) {
                const char = plainText.charAt(i);
                element.innerHTML += (char === '\n') ? '<br>' : char;
                i++;
                setTimeout(type, speed);
            } else {
                if (callback) callback();
            }
        }
        type();
    }

    function animateFinalFormation() {
        cardObjects.forEach(c => {
            if (!c.userData.isChosen && c.position.y > -10) {
                c.position.y -= c.userData.dropSpeed;
                c.rotation.x += 0.05;
            }
        });

        chosen3DMeshes.forEach(card => {
            if (card.userData.animDelay > 0) {
                card.userData.animDelay--;
                return;
            }
            if (card.userData.animProgress < 1) {
                card.userData.animProgress += 0.015;
                const t = card.userData.animProgress;
                const easeT = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                card.position.lerp(card.userData.finalTargetPos, 0.05);
                const s = THREE.MathUtils.lerp(0.2, card.userData.finalTargetScale, easeT);
                card.scale.set(s, s, s);
                const isRev = card.userData.isReversed;
                card.rotation.set(0, Math.PI, isRev ? Math.PI : 0);
            }
        });
    }

    function addToHistory(rawData, isRev) {
        const con = document.getElementById('history-container');
        const slot = document.createElement('div');
        slot.className = `history-slot ${isRev ? 'is-reversed' : ''}`;
        const t = TEXTS[currentLang];
        const data = rawData[currentLang];
        slot.innerHTML = `<img src="${rawData.url}"><div class="history-info"><div class="history-name">${data.name}</div><div class="history-rev">${t.rev}</div></div>`;
        con.appendChild(slot);
    }

    const particles = [];

    function spawnParticles(pos) {
        const count = 500;
        const geo = new THREE.BufferGeometry();
        const pArr = new Float32Array(count * 3);
        const vArr = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            pArr[i * 3] = pos.x + (Math.random() - 0.5) * CARD_W;
            pArr[i * 3 + 1] = pos.y + (Math.random() - 0.5) * CARD_H;
            pArr[i * 3 + 2] = pos.z;
            vArr[i * 3] = (Math.random() - 0.5) * 0.02;
            vArr[i * 3 + 1] = Math.random() * 0.03;
            vArr[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pArr, 3));
        const mat = new THREE.PointsMaterial({ color: GOLD_COLOR, size: 0.04, transparent: true });
        const sys = new THREE.Points(geo, mat);
        sys.userData = { life: 1.0, vels: vArr };
        scene.add(sys);
        particles.push(sys);
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const sys = particles[i],
                p = sys.geometry.attributes.position.array,
                v = sys.userData.vels;
            sys.userData.life -= 0.02;
            for (let j = 0; j < p.length / 3; j++) {
                p[j * 3] += v[j * 3];
                p[j * 3 + 1] += v[j * 3 + 1];
                p[j * 3 + 2] += v[j * 3 + 2];
            }
            sys.geometry.attributes.position.needsUpdate = true;
            sys.material.opacity = sys.userData.life;
            if (sys.userData.life <= 0) {
                scene.remove(sys);
                particles.splice(i, 1);
            }
        }
    }

    function initCamera() {
        const videoElem = document.getElementById('video-feed');
        // âš ï¸ Mediapipe: Use CDN directly, do not proxy / âš ï¸ Mediapipe æ¨¡å‹ï¼šç›´æ¥ä½¿ç”¨ CDNï¼Œä¸èµ°ä»£ç†
        const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });
        hands.onResults(res => {
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                handX += ((1 - lm[8].x) * 2 - 1 - handX) * 0.2;
                const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                const fist = lm[12].y > lm[9].y && lm[16].y > lm[13].y;
                handState = fist ? 'FIST' : (pinch < 0.05 ? 'PINCH' : 'OPEN');
                if (!isRitualComplete) {
                    document.getElementById('gesture-icon').innerText = handState === 'FIST' ? 'âœŠ' : (handState === 'PINCH' ? 'ğŸ‘Œ' : 'âœ‹');
                }
            }
        });
        const cam = new Camera(videoElem, { onFrame: async () => { await hands.send({ image: videoElem }) }, width: 320, height: 240 });
        cam.start();
    }

    // Responsive Camera Update / å“åº”å¼ç›¸æœºä½ç½®æ›´æ–°
    function updateCameraPos() {
        const aspect = window.innerWidth / window.innerHeight;
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Key: Move camera back on portrait mode to see ring / å…³é”®ï¼šç«–å±æ¨¡å¼ä¸‹ç›¸æœºåé€€ï¼Œä»¥ä¾¿çœ‹åˆ°å®Œæ•´çš„ç‰Œé˜µç¯
        if (aspect < 1) { // Portrait / ç«–å±
            camera.position.z = 1; // Further back / è·ç¦»æ›´è¿œ
            camera.position.y = 1;
        } else { // Landscape / æ¨ªå±
            camera.position.z = 0;
            camera.position.y = 0;
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        starSystem.rotation.y += 0.0002;
        if (isStarted) {
            handleInput();
            updateReturningCards();
            updateParticles();
            // ğŸ‘‰ New: Refresh Visuals / æ–°å¢ï¼šåœ¨è¿™é‡Œè°ƒç”¨è§†è§‰åˆ·æ–°
            updateCardVisuals();
        }
        renderer.render(scene, camera);
    }
    animate();


    // --- Modified: Spotlight Logic (Dominant Mode) / ä¿®æ”¹åï¼šè§†è§‰èšå…‰ç¯é€»è¾‘ (éœ¸é“æ¨¡å¼) ---
    function updateCardVisuals() {
        // Define Colors / å®šä¹‰é¢œè‰²
        const colorActive = new THREE.Color(0xffffff); // Bright (Spotlight) / äº® (èšå…‰)
        const colorDimmed = new THREE.Color(0x333333); // Dim (Background) / æš— (èƒŒæ™¯å‹æš—ï¼Œçªå‡ºä¸»è§’)

        // Emissive Strength / å‘å…‰å¼ºåº¦
        const emissiveActive = new THREE.Color(0x222222);
        const emissiveDimmed = new THREE.Color(0x000000);

        cardObjects.forEach(card => {
            // 1. Skip Chosen Cards / å·²ç»é£èµ°/æ¶ˆå¤±çš„å¡ï¼Œç›´æ¥è·³è¿‡
            if (card.userData.isChosen) return;

            let isTarget = false;

            // --- Core Logic / æ ¸å¿ƒåˆ¤æ–­é€»è¾‘ ---
            if (activeCard) {
                // Scene A: Player Holding Card / åœºæ™¯ Aï¼šç©å®¶æ‰‹é‡Œæ‹¿ç€å¡
                // Only held card is active / åªæœ‰æ‰‹é‡Œè¿™å¼ æ˜¯äº®çš„ç›®æ ‡
                if (card === activeCard) {
                    isTarget = true;
                }
            } else {
                // Scene B: Browsing Mode / åœºæ™¯ Bï¼šç©å®¶æ²¡æ‹¿å¡ (æµè§ˆæ¨¡å¼)
                // Axis card is active / åªæœ‰æ­£å¯¹ä¸­è½´çš„é‚£å¼ æ˜¯äº®çš„ç›®æ ‡
                if (card === centerCard) {
                    isTarget = true;
                }
            }
            // --------------------

            const targetColor = isTarget ? colorActive : colorDimmed;
            const targetEmissive = isTarget ? emissiveActive : emissiveDimmed;

            // Apply Color Transition / æ‰§è¡Œé¢œè‰²æ¸å˜
            card.children.forEach(mesh => {
                if (mesh.isMesh && mesh.material) {
                    // Color Lerp / é¢œè‰²è¿‡æ¸¡
                    mesh.material.color.lerp(targetColor, 0.1);

                    // Emissive Lerp (Holy Feel) / è‡ªå‘å…‰è¿‡æ¸¡ (å¢åŠ ç¥åœ£æ„Ÿ)
                    if (mesh.material.emissive) {
                        mesh.material.emissive.lerp(targetEmissive, 0.1);
                    }
                }
            });
        });
    }

    window.onresize = updateCameraPos;
</script>
</body>
</html>


